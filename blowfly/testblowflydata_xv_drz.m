function testblowdata_xv_drz()
% cross-validation for testblowdata
% Wittawat and Mijung wrote on 11 Apr 2015
% For Zoltan's regression

%clear all;
%clc;
%clf;

%% (1) load data

load flydata.mat

n = length(flydata);

%% test ssf-abc

opts.num_theta_samps = 2000;
opts.dim_theta = 6; % dim(theta)
% opts.yobs = flydata';

% split data into training and test data
cv_fold = 1;
last_idx_trn = ceil(n*3/4);
idx_trn = [ones(1, last_idx_trn), zeros(1, n - last_idx_trn)];
assert(length(idx_trn) == n);

% training indices
ntr = sum(idx_trn);
opts.num_obs = ntr;
opts.num_pseudodata_samps = 200; 
% opts.num_pseudodata_samps = 4*ntr;
opts.yobs = flydata(1:ntr)';

stat_gen_func = @ss_for_blowflydata;
likelihood_func = @ safe_gendata_op_dyn_eqn; 
proposal_dist = @(n) sample_from_prior_blowflydata(n); 
train_params = proposal_dist(opts.num_theta_samps);
train_bags = cell(1, opts.num_theta_samps);

% for each single parameter, we need to construct a summary statistic of 
% observations generated by the parameter.
for i=1:size(train_params, 2)
    theta = train_params(:, i);
    observations = likelihood_func(theta, opts.num_pseudodata_samps);
    train_bags{i} = observations;
end

% ------- options for distreg_zoltan ------------
% op = struct();
% seed = 11; 
% op.seed = seed;

% a list of regularization parameter candidates 
op.drz_reg_list = 10.^(-4:2:4);
%op.drz_reg_list = [10.^-3, 10.^-1];

% a list of Gaussian widths squared to be used as candidates for Gaussian kernel
funcs = funcs_distreg_zoltan();
subbags = 100;
med = funcs.meddistance_bags(train_bags, subbags);

howmanyscalelength = 5;
op.drz_gwidth2_list = logspace(-4,2,howmanyscalelength).* (med^2);
%op.drz_gwidth2_list = [1, 2]*med^2;

howmanyepsilon = 5;
op.drz_outwidth2_list = logspace(-5, 0, howmanyepsilon);
%op.drz_outwidth2_list = [1e-3, 1e-2];

num_obs_validate = ceil(0.75*n);
held_out_obs = flydata( (num_obs_validate+1):end);

% Loss function to be used to measure the goodness of parameters. 
% A loss function takes the form 
% f: (weights_func, train_bags, train_target ) -> real number.  
% Lower is better.
op.drz_custom_loss_func = @(weights_func, train_bags, train_target) ... 
    norm( hist(likelihood_func( train_target* weights_func( opts.yobs ),...
    opts.num_pseudodata_samps))   - hist(held_out_obs) );

% ---- training ------
%log_train_params = log(train_params);
[R, op] = distreg_zoltan_custom_loss(train_bags, train_params, op);
% R contains a regression function mapping from a bag to its param
%

display(R);

weights_func = R.regress_weights_func ;
W = weights_func(flydata(:)');
% hack to make W non-negative 
%W = max(0, W);

%%
theta_opt = train_params*W; 
simuldat = likelihood_func(theta_opt, n); 

subplot(212); plot(1:180, flydata/1000, 'k', 1:180, simuldat./1000, 'r-'); title('simulated data');
set(gca, 'ylim', [0 max(simuldat/1000) + 1])


s = ss_for_blowflydata(flydata);
% s_ours =  ss_for_blowflydata(simuldat_ours);
s_drz = ss_for_blowflydata(simuldat);
% s_sl = ss_for_blowflydata(simuldat_sl);

mse = @(a) norm(s-a);
[mse(s) mse(s_drz)]

whichmethod =  'distreg_zoltan';
save(strcat('blowflydata: ', num2str(whichmethod), '.mat'), 'R', 's', 's_drz', 'W');

% copy all the variables to the workspace
all_vars = who;
putvar(all_vars{:});

end

function dat = safe_gendata_op_dyn_eqn(theta, bag_size)
    % This is just like the blowfly likelihood function (gendata_pop_dyn_eqn) 
    % with capping of variables in place. If theta is out of range, this function 
    % will try to correct it.
    %
    assert(length(theta) == 6);

    %P = params(1);
    %delta = params(2);
    %N0 = params(3);
    %sig_d = params(4);
    %sig_p = params(5);
    %tau = round(params(6));

    % tau must be >= 0
    if theta(6) < 0
        theta(6) = 0;
    end

    % too big
    theta(6) = max(30, theta(6) );

    dat = gendata_pop_dyn_eqn(theta, bag_size);
end

