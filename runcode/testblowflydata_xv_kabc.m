% cross-validation for testblowdata
% this code is what I used for Fig 2
% mijung wrote and tested on jan 27, 2015

clear all;
clc;
clf;

%% (1) load data

load flydata.mat

n = length(flydata);

%% test ssf-abc

opts.num_theta_samps = 10000;
opts.dim_theta = 6; % dim(theta)
% opts.yobs = flydata';

% split data into training and test data
cv_fold = 1;
last_idx_trn = ceil(n*3/4);
idx_trn = [ones(1, last_idx_trn), zeros(1, n - last_idx_trn)];
assert(length(idx_trn) == n);

% training indices
ntr = sum(idx_trn);
opts.num_obs = ntr;
opts.num_pseudodata_samps = 5000; 
% opts.num_pseudodata_samps = 4*ntr;
opts.yobs = flydata(1:ntr)';

stat_gen_func = @ss_for_blowflydata;
likelihood_func = @ gendata_pop_dyn_eqn; 
proposal_dist = @(n) sample_from_prior_blowflydata(n); 
train_params = proposal_dist(opts.num_theta_samps);

train_stats = [];
% for each single parameter, we need to construct a summary statistic of 
% observations generated by the parameter.
for i=1:size(train_params, 2)
    theta = train_params(:,i);
    observations = likelihood_func(theta, opts.num_pseudodata_samps);
    stat = stat_gen_func(observations);
    train_stats(:, i) = stat;
end

% ------- options for kabc ------------
% All options are described in kabc_cond_embed
% op = struct();
% seed = 11; 
% op.seed = seed;

op.kabc_reg_list = 10.^(-10:2:10);

% a list of Gaussian widths squared to be used as candidates for Gaussian kernel
op.kabc_gwidth2_list = 2.^[-10:5].* (meddistance(train_stats)^2);


num_obs_validate = ceil(0.75*n);
observed_stat = stat_gen_func(flydata(1:num_obs_validate));
held_out_obs = flydata( (num_obs_validate+1):end);

% Loss function to be used to measure the goodness of parameters (Gaussian width ,
% regularization parameter). A loss function takes the form 
% f: (weights_func, train_stats ) -> real number.  
% Lower is better.
op.kabc_loss_func = @(weights_func, train_stats)norm(hist(likelihood_func(train_stats*weights_func(observed_stat), opts.num_pseudodata_samps))-hist(held_out_obs));
% ---- training ------
[R, op] = kabc_custom_loss(train_stats, train_params, op);
% R contains a regression function mapping from a stat to its param
%

display(R);

weights_func = R.regress_weights_func ;
W = weights_func(stat_gen_func(flydata));


%%

theta_opt = train_params*W; 
simuldat = likelihood_func(theta_opt, n); 

subplot(212); plot(1:180, flydata/1000, 'k', 1:180, simuldat./1000, 'r-'); title('simulated data');
set(gca, 'ylim', [0 max(simuldat/1000) + 1])


s = ss_for_blowflydata(flydata);
% s_ours =  ss_for_blowflydata(simuldat_ours);
s_kabc = ss_for_blowflydata(simuldat);
% s_sl = ss_for_blowflydata(simuldat_sl);

mse = @(a) norm(s-a);
[mse(s) mse(s_kabc)]

% whichmethod =  'cond_mean_embedding_abc';
% save(strcat('blowflydata: ', num2str(whichmethod), '.mat'), 'R');
